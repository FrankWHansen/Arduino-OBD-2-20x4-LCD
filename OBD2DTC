  // I've taken example code from Sparkfun, but a fixed version from kiteman (3rd post from top), at
  // https://forum.sparkfun.com/viewtopic.php?f=14&t=35507, and modified it since I'm working with
  // a parallel LCD screen and I want to read Diagnostic Trouble Code(DTC)s instead of getting a live
  // feed of data from the car (speed, rpm, coolant temp etc) like most people seem to be interested in.
  
  // I currently have an ugly prototype of a scantool, that might at any moment fall apart,
  // but my plan is to implement this work-in-progress software in a more compact and user-friendly form factor.

  // A DTC consists of a five-character code - one letter followed by four digits.
  // https://en.wikipedia.org/wiki/OBD-II_PIDs#Mode_3_.28no_PID_required.29 is a great reference to understand its composition.

  // There is a great chance this code isn't working at all because of my inexperience, but if it is,
  // take special care not to trust more than the first 2 DTCs:
  // As the link to wiki states, further DTCs will come with overhead/frames from the car, and I need to analyze the different manufacturer's protocols
  // to be able to figure out how to extract the information I need to produce more DTCs.
  
  // include library for parallel LCD screen:
  #include <LiquidCrystal.h>

  // initialize the library with the numbers of the interface pins
  LiquidCrystal lcd(7, 8, 9, 10, 11, 12);

  //This is a character buffer that will store the data from the serial port
  char rxData[20];
  char rxIndex=0;

  // An array that stores the 4 possible letters that make out the most significant value of the DTC
  char DTCletter[5] = {'P', 'C', 'B', 'U', '\0'}; // P = Powertrain, C = Chassis, B = Body, U = Network, '\0' = null character that arrays apparently always technically end with.

  // I'll make room for 8 DTCs. Each row in this array will store a DTC of five chars plus the null character.
  char DTCarray[8][6];

  // setup() only runs once
void setup() {
  // Initiate serial connection with OBD-2 board @ 9600 baud
  Serial.begin(9600);
  
  // set up the LCD's number of columns and rows:
  lcd.begin(20, 4);
  // Print a message to the LCD.
  lcd.setCursor(0,1);
  lcd.print("On-Board Diagnostics");
  lcd.setCursor(1,1);
  // just a simple test to see if the variables are stored correctly in DTCletter[]
  lcd.print(DTCletter);
  // Runs function OBD_init() to reset the board and turn off echoing
  OBD_init();
  lcd.clear();
  //delay(250);
}

  // after setup() runs once, loop() can run indefinitely
void loop() {
  // Delete any data that may be left over in the serial port.
  Serial.flush();
  getDTC(); //run getDTC() to retrieve fault codes
  // delay 240 seconds to be able to write down the codes before the loop starts over.
  // This is just a temporary delay, while I figure out how to take things further.
  delay(240000);
  
}

void OBD_init(void) {
  //Wait for a little while before sending the reset command to the OBD-II-UART
  delay(2000);
  //Reset the OBD-II-UART
  Serial.print("ATZ\r");
  //Wait for a bit before starting to send commands after the reset.
  delay(2000);
  OBD_read();
  Serial.print("ATE0\r");
  OBD_read();
  Serial.flush();
}

void getDTC(void) {
  Serial.flush();
  // OBD-2 mode 03 means "Read DTCs!"
  Serial.print("03\r");
  // read incoming data from OBD-2 card
  OBD_read();
  // give the car a reasonable time to respond, this might be entirely unnecessary, but good for testing
  delay(1000);
  // count variable that will simplify the for loop a lot
  int loopCount = sizeof(rxData[0]) / 2;
  // I will make a separate variable to make sure we can go through one byte of rxData at a time
  int byteCount = 0;
  // Each iteration will go through 2 bytes
  for (int i = 0; i < loopCount; i++) {
    // Set the first char in each row of the two-dimensional char array to whatever the output of DTCletter[letter] is.
    DTCarray[i][0] = DTCletter[rxData[i] >> 6];
    // The first digit also consists of only two bits (decimal values range from 0 up to and including 3).
    DTCarray[i][1] = ((rxData[byteCount] >> 4) & 0b00000011);
    // The last three digits are each one nibble (half-byte)
    DTCarray[i][2] = (rxData[byteCount] & 0xf);
    // Now we've depleted the first byte of information in this DTC, so we move on to the second one.
    byteCount++;
    DTCarray[i][3] = (rxData[byteCount] >> 4 & 0xf);
    DTCarray[i][4] = (rxData[byteCount] & 0xf);
    byteCount++;
  }
  for (int i = 0; i < 8; i++) {
    // I came up with this way of moving the cursor around while keeping int i simple, and it seems pretty neat (Let's pray it works)!
    lcd.setCursor((floor(i / 4) * 10), i % 4);
    for (int j = 0; j > 6; j++) {
      lcd.print("DTC" + (i + 1) + ':' + DTCarray[i][j]);
    }
  }
}

// This function stores each byte read in a local char c, and adds it to the global buffer array rxData[]
void OBD_read(void) {
  char c;
  do{
    // basically, if there's traffic, parse it
    if(Serial.available() > 0)
    {
      c = Serial.read();
      //lcd.print(c);
      if((c!= '>') && (c!='\r') && (c!='\n')) //Keep these out of our buffer
      {
        rxData[rxIndex++] = c; //Add whatever we receive to the buffer
      }
     }
  }while(c != '>'); //The ELM327 ends its response with this char so when we get it we exit out.
  rxData[rxIndex++] = '\0';//Converts the array into a string
  rxIndex=0; //Set this to 0 so next time we call the read we get a "clean buffer"
}
